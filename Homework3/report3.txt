--------------------------

学籍番号 : 1515829
氏名 :李　墨然

--------------------------

回答1 :
1.1) OrderedShapeManagerの実装についての説明
利用したクラスについてや、最小限の実装行で済ませる工夫などを説明して下さい。

CollectorのサブクラスのTreeSetを利用して、Comparator定義して、idが小さいと先に来るように設定する。



1.2)
空欄Aに入る語は：カプセル化
空欄Bに入る語は：同期実行




回答２ :
2.1) para.Main05のメンバ変数valueに直接関連した処理を行うスレッド名と
その役割はそれぞれ次のとおり

スレッド名   |　役割
---------------------------------
Thread-3    | valueを読み取って、モグラを書く
JavaFX Application thread | Application内発生する出来事を監視する



2.2)
ユーザ視点でのプログラムの不具合

slideの値を急に変更したらモグラの大きさはすぐに変更しないが、ある程度時間が経ったら大きいが急に変更した。




不具合の原因についての講義で説明されたプログラムを処理する仕組みに基づいた説明

valueはvolatileをつけていないので、モグラを描画するときはThread最新の数を常に更新されることが保証できない。



回答3 :
3.1)
配布されたpara.Main06による仕様のように動かない挙動の説明

たまにdecementの窓にincrementの窓に書かれるべきのものが書かれて、その時、incrementの窓にdecementの窓に書かれるべきのものが書かれる







3.2)
つぎのどちらかの行を消して回答せよ

メソッドduplicate()は shallow copy である。

スレッドセーフであると考える場合、その理由の説明

スレッドセーフである。sm1とsm2の中にのオブジェクトは最初が同じ共有しているものであるが、そのオブジェクト変更する手段を持っていないので、スレッドセーフである。





スレッドセーフでないと考える場合、ソースコード修正部分とその説明







回答4 :
4.1)
２つのスレッド
１つ目のスレッドとその役割は次のとおり

JavaFX Application Thread
Application内の出来事を監視して反応する

２つ目のスレッドとその役割は次のとおり

作られたThread　thread
モグラをランダム作って、さらにxyの情報を読み取って、円を描画する。

4.2)
para.game.GameFrameのメンバ変数xyについてsynchronizedメソッドによる同
期を行わなかった場合に生じる不正確なデータの処理の例は次のとおり

Clickするとき、JavaFX Application ThreadがClickを処理するとき、copyとかgetなどのメソッドは今のものではなくて過去のものを獲得する可能性があるので、Clickしても実際には反応されない可能性がある。



volatile修飾では不十分であることの理由

volatileはオブジェクトに対してはオブジェクトに指すポインタを常に更新することが保証されるが、ポインタ内のものが最新のものに更新することが保証されない。




4.3)
para.game.GameFrameのメンバ変数leftonやrightonにvolatile修飾を付けるこ
とでマルチスレッドに対応できることの説明

leftonやrightonはintなので、常に最新のものに更新することが保証される。





4.4)
ゲーム性を高めるために行った実装についての説明
得点ルールとその計算法の実装

当たったら得点プラス5
グローバル変数にint pointを加えて、sが検出されたら、point+=5をする


得点を表示するために行った実装

ShapeManegerのismに点数表示のDigitを入れることによって実装する




課題3で表示される図形を利用するための実装

moleメソッドのところの図形のところにGardenのメソッドを利用してosmに画像を入れる




ゲームの終了条件を定めるための実装

pointが100になったらThreadのwhileの条件flagをfalseにして、ゲームを終わらせる。




4.5)
更なるゲーム性の向上のための追加実装についての説明

難易度変更用の方法をslideを利用して実装した。







工夫した点や感想：
